from random import randint, choice # Импортируем из модуля random функции randint, choice
from time import time # Импортируем из модуля time функцию time

def lin_poisk(x, xx): # Создаем функцию линейного поиска, переменными которой будут нужное для поиска число и масив, в котором будет вестись поиск
    for i in range(len(xx)): # Перебираем все элементы по индексам
        if xx[i] == x: # Если элемент равен нужному нам числу, то возвращаем его индекс
            return  f"Ваше число находится на {i+1} месте"
        else: # Если не равен, то пропускаем итерацию
            continue
    return "Число не найдено" # Если функция range закончилась - значит нету ни одного такого элемента

def dvoichn_poisk(x, xx): # Создаем функцию двоичного поиска, переменными которой будут нужное для поиска число и масив, в котором будет вестись поиск
    xx.sort() # Чтобы избежать ошибки, если список был не отсортирован - сортируем его
    l = 0 # Создаем индекс левой границы масива
    r = len(xx) # Создаем индекс правой границы масива
    while True: # Создаем бесконечный цикл
        c = (r + l)//2 # Ищем индекс серединнного элемента между d и s
        if xx[c] == x: # Если серединный элемент равен заданному числу
            return f"Ваше число находится на {c+1} месте" # Печатаем его индекс
        elif x > xx[c]: # Если серединный элемент меньше заданного числа
            l = c # Сдвигаем левую границу, приравнивая ее индексу центрального элемента
        elif x < xx[c]: # Если серединный элемент больше заданного числа
            r = c # Сдвигаем правую границу, приравнивая ее индексу центрального элемента
        if len(xx[l:r]) == 1: # Если длина масива от левой границы до правой равна 1, значит остался всего элемент неравный заданному числу
            return "Такого элемента не существует в данном списке" # Печатаем об его отсутствии

def sort_vibor(x): # Создаем функцию сортироовки выбором, принимающую на вход неотсортированный список
    for i in range(len(x)):  # Создаем функцию range для всех чисел списка
        m = float("inf")  # Создаем бесконечно большое число
        n = 0
        for s in range(i, len(x)):  # Перебираем список от i до конца списка, сдвигая границу проверки
            if m > x[s]:  # Ищем минимум в заданном промежутке, уменьшая m, если x[s] меньше
                m = x[s]  # Отбираем минимум
                n = s  # Запоминаем индекс минимума
        x[i], x[n] = x[n], x[i]  # Меняем местами левую границу с минимальным элементом из промежутка
    return x # Возвращаем отсортированный список

def sort_puzir(x): # Создаем функцию сортироовки пузырьком, принимающую на вход неотсортированный список
    for i in range(len(x) - 1): # Перебираем список, кроме последнего элемента
        for j in range(len(x) - i - 1): # Перебираем элементы на i меньше, чем предыдущий range
            if x[j] > x[j + 1]: # Если элемент больше последующего
                x[j], x[j + 1] = x[j + 1], x[j] # то меняем эти элементы местами, сдвигая большие числа в правую часть
    return x # Возвращаем отсортированный список

def sort_vstavka(x): # Создаем функцию сортироовки вставкой, принимающую на вход неотсортированный список
    for i in range(len(x)): # Перебираем все элементы масива по индексам
        k = i - 1 # Создаем индекс-число, стоящий левее от i
        s = x[i] # Запоминаем элемент по индексу i
        while x[k] > s and k >= 0: # Алгоритм будет переставлять все элементы, стоящие правее от i, на одно значание влево,
            # А после в освободившуюся ячейку вставллять элемент меньший тех, что перебирали
            # Перебор осуществляется до нулевого элемента: k >= 0
            x[k+1] = x[k] # Переставляем элемент на один влево
            k -= 1 # Уменьшаем k
        x[k+1] = s # В освободившееся место вставляем элемент s
    return x # Возвращаем отсортированный список

def sort_fast(x): # Создаем функцию быстрой сортироовки, принимающую на вход неотсортированный список
    # Функция рекурсивная, поэтому
    if len(x) <= 1: # Если длина оставшегося масива <= 1
        return x # То возвращаем отсортированный список
    else: # В другом случае
        q = choice(x) # Выбираем q - рандомный элемент из списка x
    mensh = [n for n in x if n < q] # Создаем список, заполняемый элементами из x, меньшими чем q
    sredn = [q] * x.count(q) # Создаем список, заполняемый элементами из x, равными q
    bolsh = [n for n in x if n > q] # Создаем список, заполняемый элементами из x, большими чем q
    return sort_fast(mensh) + sredn + sort_fast(bolsh) # Возвращаем список соединяющий элементы меньших q, элементы равные q и элементы большие q

def rabota():
    with open("../1.txt") as f:  # Открываем файл на чтение
        dd = f.read().split()  # Записываем все числа в список, так как это строка, разбиваем ее функцией split
        d = [int(sim) for sim in dd]  # Меняем тип элементов списка на int
        g = int(input("Использовать метод линейного поиска - нажмите 1. \n"
                      "Использовать метод двоичного поиска в упорядоченному масиве - нажмите 2. \n"
                      "Использовать метод сортировки выбором - нажмите 3. \n"
                      "Использовать метод сортировки пузырьком - нажмите 4. \n"
                      "Использовать метод сортировки вставкой - нажмите 5. \n"
                      "Использовать метод быстрой сортировки - нажмите 6. \n"))
        # Запрашиваем желаемое действие
        if g == 1:
            e = int(input("Какое число нужно найти? "))
            start = time()  # Записываем начальное время функцией time
            print(lin_poisk(e, d), f"\nВремя выполнения программы {format((time() - start), '.10f')}")
            # Выводим функцию линейного поиска и разницу времени между концом работы программы и ее началом, оставляя 10 знаков после запятой
        elif g == 2:
            e = int(input("Какое число нужно найти? "))
            start = time()  # Записываем начальное время функцией time
            print(dvoichn_poisk(e, d), f"\nВремя выполнения программы {format((time() - start), '.10f')}")
            # Выводим функцию двоичного поиска и разницу времени между концом работы программы и ее началом, оставляя 10 знаков после запятой
        elif g == 3:
            start = time()  # Записываем начальное время функцией time
            k = sort_vibor(d)  # Вызываем функцию сортировки выбором
            print(f"Время выполнения программы {format((time() - start), '.10f')}")
            # Печатаем разницу времени между концом работы программы и ее началом, оставляя 10 знаков после запятой
            p = ''  # Создаем пустую строку
            for u in k:  # Перебираем все элементы отработавшей функции
                p += f"{u} "  # Прибавляем к строке элемент и пробел после него
            with open("../resultat.txt", "w") as h:  # Открываем файл на запись
                h.write(p)  # Записываем строку в файл
        elif g == 4:
            start = time()  # Записываем начальное время функцией time
            k = sort_puzir(d)  # Вызываем функцию сортировки пузырьком
            print(f"Время выполнения программы {format((time() - start), '.10f')}")
            # Печатаем разницу времени между концом работы программы и ее началом, оставляя 10 знаков после запятой
            p = ''  # Создаем пустую строку
            for u in k:  # Перебираем все элементы отработавшей функции
                p += f"{u} "  # Прибавляем к строке элемент и пробел после него
            with open("../resultat.txt", "w") as h:  # Открываем файл на запись
                h.write(p)  # Записываем строку в файл
        elif g == 5:
            start = time()  # Записываем начальное время функцией time
            k = sort_vstavka(d)  # Вызываем функцию сортировки вставками
            print(f"Время выполнения программы {format((time() - start), '.10f')}")
            # Печатаем разницу времени между концом работы программы и ее началом, оставляя 10 знаков после запятой
            p = ''  # Создаем пустую строку
            for u in k:  # Перебираем все элементы отработавшей функции
                p += f"{u} "  # Прибавляем к строке элемент и пробел после него
            with open("../resultat.txt", "w") as h:  # Открываем файл на запись
                h.write(p)  # Записываем строку в файл
        elif g == 6:
            start = time()  # Записываем начальное время функцией time
            k = sort_fast(d)  # Вызываем функцию быстрой сортировки
            print(f"Время выполнения программы {format((time() - start), '.10f')}")
            # Печатаем разницу времени между концом работы программы и ее началом, оставляя 10 знаков после запятой
            p = ''  # Создаем пустую строку
            for u in k:  # Перебираем все элементы отработавшей функции
                p += f"{u} "  # Прибавляем к строке элемент и пробел после него
            with open("../resultat.txt", "w") as h:  # Открываем файл на запись
                h.write(p)  # Записываем строку в файл

def fail(): # Создаем функцию работы с файлами и всеми функциями
    while True: # Создаем бесконечный цикл
        try: # Создаем обработчик ошибок
            n = int(input("Если вы хотите создать новый файл - нажмите 1. \n"
                  "Если вы хотите работать со старым файлом - нажмите 2. \n"
                          "Если вы хотите завершить работу - нажмите 3. \n"))
            # Запрашиваем желаемое действие
            if n == 1:
                s = int(input("Введите длину масива: "))
                with open("../1.txt", "w") as f: # Открываем файл на запись
                    a = '' # Создаем пустую строку
                    for i in range(s):
                        a += f"{randint(-100_000, 100_000)} " # Заполняем строку числами, разделенными пробелами
                        # Числа получаем из функции randint модуля random
                    f.write(a) # Строку записываем в файл
                rabota()
            if n == 2:
                rabota()
            if n == 3:
                print("Работа завершена")
                # Завершаем программу
                break
        except Exception as ex: # Обрабатываем возникшие ошибки, если они возникли
            print(ex)
if __name__ == "__main__":
    fail() # Запусаем программу
